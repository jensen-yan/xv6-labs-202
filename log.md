

#### 任务2
进程调度这一块还没有弄得很明白
ls.c 中最后exit(0) 只是释放文件资源, 变成僵尸态, 还需要等待父进程(initcode = shell) 来调用wait来释放进程资源
exit最后会进入sched()函数, 执行swtch(&p->context, &mycpu()->context);
这里的mycpu-> context到底是什么呢, 似乎返回到scheduler()函数那里, 然后页表切换回全局的内核页表, 在内核栈中运行
这里的内核栈应该是shell进程的内核栈吧, 何时调用wait?
scheduler 的进程切换前后是否应该切换页表, 还没想太清楚

bug1:
ls 后 panic: freewalk: leaf
调用freewalk前要释放所有叶节点, 之前没解除完关系

bug2:
第二次ls, panic: remap
是mappages中映射页表可能: 应该写到新进程页表, 却写入了全局页表中
原因: kalloc申请内核栈写入全局页表中, 出现了重复映射, 因为原来的内核栈页被释放了? 又写到同一个地方?
原来内核栈proc[2] 那里写入了一个内核栈映射, 现在进程结束了, 但是内核栈映射却没有删除, 导致重复映射了
要不内核栈映射就不做了? 但是这里出现kvmpa: 在全局页表中对3ffffffdf10地址的映射*pte的valid=0
好吧, 直接修改kvmpa中的地方, 需要修改成调用当前内核页表!
注意需要先定义spinlock, 然后才是proc.h, 声明顺序居然也有要求, 服了

终于完成任务2了, 确实有难度, 继续加油, 我很棒!


#### 任务3
之前只是完成了每个进程一个内核页表, 和全局页表基本一样, 只是全局页表没有映射每个进程内核栈, 而内核页表把当前进程内核栈映射到
同一个虚地址上了, 其他都完全一样.
现在需要把进程的用户页表部分, 每个映射关系也拷贝到内核页表中, 
原来时候: 内核需要访问syscall 传递的用户指针, 内核需要先转换成物理地址, 希望内核能直接找到物理地址
这样copyin_new 就不用从全局页表查找直接映射, 能直接找从内核页表查找用户地址

用于简化copyin, 先试试

需要防止用户进程使用0x0c00_0000以上的地址? 用户只会使用0到0xc00_0000的地址, 内核用0x8000_0000以上的地址

修改了fork, exec , 为内核页表添加了
bug1: sepc=0x0000000080000d8a stval=0x000000000000002b
panic: kerneltrap
这是在initcode这里使用copyin发送例外
注意: initcode 调用 exec("/init"), 然后进入init线程, fork, exec("sh"), 这时候有两个进程init,sh
说明我的initcode还没有映射内核页表, 添加成功了

bug2: sepc=0x0000000080000d8a 

在freeproc中

说明init进程没有映射内核页表, 应该在fork中映射的

已经有点晕了, 每太明白为何会有这个问题, 之后再调试吧

终于解决了, fork那里复制映射是子进程的!



bug3: 能启动shell, ls后sepc=0x0000000080000d8a 

这里会调用sbrk来扩大内存, 添加映射吧, 成功了



bug4: 运行usertests panic: uvmunmap: not mapped

似乎是用户进程太大了, 超过了plic的东西, 这个还是要改啊

添加plic的判断, 成功了, 但是还不是很理解为何要限制用户进程空间在0x0c00_0000以下?